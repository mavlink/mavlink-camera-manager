<html>
<head>
    <title>MAVLink Camera Manager</title>
    <meta charset="utf-8" />
    <script src="https://unpkg.com/viz.js@2.1.2/viz.js"></script>
    <script src="https://unpkg.com/viz.js@2.1.2/full.render.js"></script>

    <style>
        :root {
            color-scheme: dark;
        }
        .dot-container {
            margin: 1em 0;
            padding: 1em;
            border: 1px solid #444;
            border-radius: 4px;
        }
        .dot-content {
            max-width: 800px;
            max-height: 300px;
            overflow: auto;
            margin: 0 auto;
            background: #222;
            border-radius: 4px;
            padding: 1em;
            cursor: pointer;
            transition: background-color 0.2s;
            position: relative;
        }
        .dot-content:hover {
            background: #2a2a2a;
        }
        .dot-content::after {
            content: "Click to open in new tab";
            position: absolute;
            bottom: 0.5em;
            right: 0.5em;
            font-size: 0.8em;
            color: #666;
            pointer-events: none;
        }
        .dot-content svg {
            display: block;
            width: 100%;
            height: auto;
            cursor: pointer !important;
        }

        /* Iframe styles */
        .pipeline-container iframe {
            width: 100%;
            height: 100%;
            border: none;
            background: #222;
        }

        .iframe-controls {
            display: flex;
            gap: 0.5em;
            margin-bottom: 1em;
            padding: 1em;
            background: #222;
        }

        .iframe-controls button {
            padding: 0.5em 1em;
            border: 1px solid #444;
            border-radius: 4px;
            background: #333;
            color: #fff;
            cursor: pointer;
        }

        .iframe-controls button:hover {
            background: #444;
        }

        .svg-container {
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            height: calc(100% - 4em);
        }

        .svg-container svg {
            width: 100%;
            height: auto;
            max-height: 100%;
            transform-origin: center center;
            transition: transform 0.2s ease;
        }
    </style>
</head>

<body>
    <div id="app" style="display: flex; column-gap: 1em">
        <div style="display: flex; column-gap: 1em">
            <div v-for="item in content">
                <div>
                    <h3>Camera: {{ item.name }}</h3>
                </div>
                <div>
                    <p>Device: {{ item.source }}</p>
                </div>
                <h4>
                    Configure Stream:
                </h4>
                <div>
                    <streamform :device="item" :streams="streams" v-on:onconfigure="(value) => configureStream(value)">
                </div>
                <h4>
                    Controls:
                </h4>
                <div>
                    <button type="button" v-on:click="resetControls(item.source)">Reset controls</button>
                </div>
                <div v-for="control in item.controls">
                    <h5>Name: {{ control.name }}</h5>
                    <div v-if="control.configuration.Slider">
                        <v4lslider
                            :slider="control.configuration.Slider"
                            :name="control.id.toString()"
                            v-on:onchange="(value) => setControl(item.source, control.id, value)"
                        ></v4lslider>
                    </div>

                    <div v-if="control.configuration.Bool">
                        <input
                            type="checkbox"
                            :checked="control.configuration.Bool.value == 1"
                            @change="(event) => setControl(item.source, control.id, event.target.checked ? 1 : 0)"
                            >
                        <label>On</label>
                    </div>

                    <div v-if="control.configuration.Menu">
                        <select
                            @change="(event) => setControl(item.source, control.id, event.target.value)"
                        >
                            <option
                                v-for="option in control.configuration.Menu.options"
                                v-bind:value="option.value"
                                :selected="option.value == control.configuration.Menu.value"
                                >
                                {{option.name}}
                            </option>
                        </select>
                    </div>
                </div>
            </div>
            <div>
                <h3>Streams</h3>
                <button type="button" v-on:click="openWebsiteInTab('webrtc/index.html')">WebRTC website</button>
                <div v-for="stream in streams">
                    <div>
                        <h3>Name: {{ stream.video_and_stream.name }}</h3>
                    </div>
                    <div>
                        <p>Video: {{ getVideoDescription(stream.video_and_stream) }}
                        </p>
                    </div>
                    <div>
                        <button type="button" v-on:click="deleteStream(stream.video_and_stream.name)">Delete stream</button>
                    </div>
                    <div>
                        <p>Endpoints:</p>
                        <div style="margin-left: 0.5em;" v-for="endpoint in stream.video_and_stream.stream_information.endpoints">
                            <p>{{ endpoint }}</p>
                        </div>
                    </div>
                    <div>
                        <p>Configuration:</p>
                        <pre style="margin-left: 0.5em;">{{ JSON.stringify(stream, undefined, 2) }}</pre>
                    </div>
                    <div class="dot-container">
                        <h4>Pipeline Visualization:</h4>
                        <div class="dot-content" @click="openDotInNewTab(stream.video_and_stream.name)">
                            <div :id="'dot-' + stream.video_and_stream.name"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <script src="vue.js"></script>
    <script>
        const app = Vue.createApp({
            mounted: function () {
                this.requestData()
                this.connectDotWebSocket()
            },
            methods: {
                connectDotWebSocket: function() {
                    const ws = new WebSocket(`ws://${window.location.host}/dot`)
                    ws.onopen = () => {
                        console.log('DOT WebSocket connected')
                    }
                    ws.onmessage = (event) => {
                        try {
                            const dots = JSON.parse(event.data)
                            dots.forEach(dot => {
                                const stream = this.streams.find(s => s.id === dot.id)
                                if (stream) {
                                    console.log('Processing stream:', stream.video_and_stream.name)

                                    // Clear existing content before rendering new dots
                                    const container = document.getElementById(`dot-${stream.video_and_stream.name}`)
                                    if (container) {
                                        container.innerHTML = ''
                                    }

                                    if (dot.dot && typeof dot.dot === 'string' && dot.dot.trim() !== '') {
                                        console.log('Rendering main dot for:', stream.video_and_stream.name)
                                        this.renderDot(stream.video_and_stream.name, dot.dot, 0)
                                    } else {
                                        console.log('Skipping invalid main dot for:', stream.video_and_stream.name)
                                    }

                                    if (dot.children && Array.isArray(dot.children)) {
                                        console.log('Processing children for:', stream.video_and_stream.name)
                                        dot.children.forEach((childDot, index) => {
                                            if (childDot && typeof childDot === 'string' && childDot.trim() !== '') {
                                                console.log('Rendering child dot:', index + 1)
                                                this.renderDot(stream.video_and_stream.name, childDot, index + 1)
                                            } else {
                                                console.log('Skipping invalid child dot:', index + 1)
                                            }
                                        })
                                    }
                                }
                            })
                        } catch (error) {
                            console.error('Error processing DOT data:', error)
                        }
                    }
                    ws.onerror = (error) => {
                        console.error('DOT WebSocket error:', error)
                    }
                    ws.onclose = () => {
                        console.log('DOT WebSocket closed, reconnecting...')
                        setTimeout(() => this.connectDotWebSocket(), 1000)
                    }
                },
                renderDot: async function(streamName, dot, streamIndex = 0) {
                    console.log('Rendering DOT for stream:', streamName, 'index:', streamIndex)
                    const container = document.getElementById(`dot-${streamName}`)
                    if (!container) {
                        console.error('Container not found for stream:', streamName)
                        return
                    }

                    // Skip if dot is empty, undefined, or doesn't contain valid DOT syntax
                    if (!dot ||
                        typeof dot !== 'string' ||
                        dot.trim() === '' ||
                        !dot.includes('digraph') && !dot.includes('subgraph')) {
                        console.log('Skipping invalid dot for stream:', streamName, 'index:', streamIndex, 'content:', dot)
                        return
                    }

                    try {
                        const viz = new Viz()

                        let wrapper = container.querySelector('.dot-wrapper')
                        if (!wrapper) {
                            wrapper = document.createElement('div')
                            wrapper.className = 'dot-wrapper'
                            wrapper.style.display = 'flex'
                            wrapper.style.flexDirection = 'column'
                            wrapper.style.gap = '1em'
                            container.innerHTML = ''
                            container.appendChild(wrapper)
                        }

                        const dotContainer = document.createElement('div')
                        dotContainer.className = `dot-container-${streamIndex}`

                        console.log('Attempting to render DOT')
                        const result = await viz.renderString(dot)
                        if (!result || result.trim() === '') {
                            console.error('Empty result from viz.renderString')
                            return
                        }
                        dotContainer.innerHTML = result
                        wrapper.appendChild(dotContainer)

                    } catch (error) {
                        console.error('Failed to render DOT:', error, 'Content:', dot)
                        const errorContainer = document.createElement('pre')
                        errorContainer.textContent = dot
                        wrapper.appendChild(errorContainer)
                    }
                },
                openWebsiteInTab: function(url) {
                    window.open(url, '_blank')
                },
                getVideoDescription: function(video_and_stream) {
                    let response = ''
                    switch (video_and_stream.stream_information.configuration.type) {
                        case 'redirect': break
                        default: {
                            response += video_and_stream.stream_information.configuration.encode
                            + ' ' + video_and_stream.stream_information.configuration.width
                            + 'x' + video_and_stream.stream_information.configuration.height
                            + ' @ ' + video_and_stream.stream_information.configuration.frame_interval.denominator
                            + ' / ' + video_and_stream.stream_information.configuration.frame_interval.numerator + ' FPS'
                        }
                    }
                    response += ', Thermal: ' + video_and_stream.stream_information.extended_configuration?.thermal ?? false
                    response += ', Disable Mavlink: ' + video_and_stream.stream_information.extended_configuration?.disable_mavlink ?? false
                    response += ', Disable Zenoh: ' + video_and_stream.stream_information.extended_configuration?.disable_zenoh ?? false
                    response += ', Disable Thumbnails: ' + video_and_stream.stream_information.extended_configuration?.disable_thumbnails ?? false
                    response += ', Disable Recording: ' + video_and_stream.stream_information.extended_configuration?.disable_recording ?? false
                    return response
                },
                requestData: async function() {
                    const response_content = await fetch('v4l')
                    this.content = await response_content.json()

                    const response_streams = await fetch('streams')
                    this.streams = await response_streams.json()
                },
                setControl: async function(source, id, value) {
                    console.log(`Configuring: source: ${source}, control_id: ${id}, value: ${value}`)
                    const settings = {
                        method: 'POST',
                        body: JSON.stringify({ "device": source, "v4l_id": Number(id), "value": Number(value) }),
                        headers: {
                            Accept: 'application/json',
                            'Content-Type': 'application/json',
                        }
                    }
                    const response = await fetch('v4l', settings)
                    this.checkResponse(response)
                },
                resetControls: async function(source) {
                    console.log(`Resetting: source: ${source} controls to its default values.`)
                    const settings = {
                        method: 'POST',
                        body: JSON.stringify({ "device": source }),
                        headers: {
                            Accept: 'application/json',
                            'Content-Type': 'application/json',
                        }
                    }
                    const response = await fetch('camera/reset_controls', settings)
                    this.checkResponse(response)
                },
                deleteStream: async function(stream_name) {
                    console.log(`Deleting stream: ${stream_name}`)

                    const url = new URL('delete_stream', window.location)
                    url.searchParams.set("name", stream_name)
                    const response = await fetch(url, {method: "DELETE"})
                    this.checkResponse(response).then(() => this.requestData())
                },
                checkResponse: async function(response) {
                    if (!response.ok) {
                        // To make the alert text more human readable, here we are:
                        //   1. removing the external double quotes pair, making the string `"text"` turns into `text`
                        //   2. unescaping new lines, making the string `text\\n newline` turns into `text\n newline`
                        //   3. unescaping double quotes, making the  string `text \\"quoted\\"` turns into `text \"quoted\"`
                        const text = await response.text().then((text) => text.replace(/^"(.+(?="$))"$/, '$1').replaceAll("\\n", "\n").replaceAll("\\\"", "\""))
                        console.warn(`Something went wrong: ${text}`)
                        alert(text)
                    } else {
                        const contentType = response.headers.get("content-type")
                        if(contentType && contentType.indexOf("application/json") !== -1) {
                            return await response.json()
                        }
                    }
                    return undefined
                },
                configureStream: async function(stream) {

                    const configuration = (() => {
                        switch (stream.source) {
                            case "Redirect": return {
                                "type": "redirect",
                            }
                            default: return {
                                "type": "video",
                                "encode": stream.configuration.encode,
                                "height": Number(stream.configuration.size.height),
                                "width": Number(stream.configuration.size.width),
                                "frame_interval": stream.configuration.interval,
                            }
                        }
                    })()

                    const content = {
                        "name": stream.name,
                        "source": stream.source,
                        "stream_information": {
                            "endpoints": stream.endpoints ? stream.endpoints.split(',') : ["udp://0.0.0.0:5600"],
                            "configuration": configuration,
                            "extended_configuration": {
                                "thermal": Boolean(stream.extended_configuration.thermal),
                                "disable_mavlink": Boolean(stream.extended_configuration.disable_mavlink),
                                "disable_zenoh": Boolean(stream.extended_configuration.disable_zenoh),
                                "disable_thumbnails": Boolean(stream.extended_configuration.disable_thumbnails),
                                "disable_recording": Boolean(stream.extended_configuration.disable_recording),
                            },
                        }
                    }
                    console.log(`Configuring new strem: ${JSON.stringify(content, null, 2)}`)

                    const settings = {
                        method: 'POST',
                        body: JSON.stringify(content),
                        headers: {
                            Accept: 'application/json',
                            'Content-Type': 'application/json',
                        }
                    }
                    const response = await fetch('streams', settings)
                    this.checkResponse(response).then(() => this.requestData())
                },
                processDotData: function(data) {
                    const parsed = JSON.parse(data)
                    for (const dot of parsed) {
                        const stream = this.streams.find(s => {
                            const streamId = s.video_and_stream.id.toString()
                            const dotId = dot.id.toString()
                            return streamId === dotId
                        })
                        if (!stream) {
                            continue
                        }
                        this.renderDot(stream.video_and_stream.name, dot.dot)
                    }
                },
                openDotInNewTab: function(streamName) {
                    const container = document.getElementById(`dot-${streamName}`)
                    if (!container) return

                    const wrapper = container.querySelector('.dot-wrapper')
                    if (!wrapper) return

                    // Create a new window with all SVGs
                    const newWindow = window.open('', '_blank')

                    // Create the HTML content
                    const html = [
                        '<!DOCTYPE html>',
                        '<html>',
                        '<head>',
                        '    <title>Pipeline Visualization - ' + streamName + '</title>',
                        '    <style>',
                        '        body {',
                        '            margin: 0;',
                        '            padding: 0;',
                        '            background: #1a1a1a;',
                        '            color: #fff;',
                        '            display: flex;',
                        '            flex-direction: column;',
                        '            min-height: 100vh;',
                        '        }',
                        '        .container {',
                        '            width: 100%;',
                        '            margin: 0;',
                        '            padding: 0;',
                        '            display: flex;',
                        '            flex-direction: column;',
                        '        }',
                        '        .pipeline-container {',
                        '            width: 100%;',
                        '            margin: 0;',
                        '            padding: 1em;',
                        '            display: flex;',
                        '            flex-direction: column;',
                        '            box-sizing: border-box;',
                        '        }',
                        '        .pipeline-title {',
                        '            margin: 0 0 0.5em 0;',
                        '            color: #fff;',
                        '            font-size: 1.2em;',
                        '        }',
                        '        iframe {',
                        '            width: 100%;',
                        '            height: 500px;',
                        '            border: 1px solid #444;',
                        '            border-radius: 4px;',
                        '            background: #222;',
                        '            box-sizing: border-box;',
                        '        }',
                        '    </style>',
                        '</head>',
                        '<body>',
                        '    <div class="container">',
                        '        <div id="pipelines"></div>',
                        '    </div>',
                        '</body>',
                        '</html>'
                    ].join('\n')

                    newWindow.document.write(html)
                    newWindow.document.close()

                    // Add all SVGs to the new window
                    const pipelinesContainer = newWindow.document.getElementById('pipelines')
                    const svgs = wrapper.querySelectorAll('svg')

                    // Function to create iframe content
                    function createIframeContent(svg) {
                        return [
                            '<!DOCTYPE html>',
                            '<html>',
                            '<head>',
                            '    <style>',
                            '        body {',
                            '            margin: 0;',
                            '            padding: 0;',
                            '            background: #222;',
                            '            overflow: hidden;',
                            '            height: 100vh;',
                            '        }',
                            '        .svg-container {',
                            '            position: relative;',
                            '            width: 100%;',
                            '            height: 100%;',
                            '            overflow: hidden;',
                            '        }',
                            '        .controls {',
                            '            position: absolute;',
                            '            top: 1em;',
                            '            left: 1em;',
                            '            z-index: 1000;',
                            '            display: flex;',
                            '            gap: 0.5em;',
                            '            background: rgba(34, 34, 34, 0.8);',
                            '            padding: 0.5em;',
                            '            border-radius: 4px;',
                            '            backdrop-filter: blur(4px);',
                            '        }',
                            '        .controls button {',
                            '            padding: 0.5em 1em;',
                            '            border: 1px solid #444;',
                            '            border-radius: 4px;',
                            '            background: #333;',
                            '            color: #fff;',
                            '            cursor: pointer;',
                            '        }',
                            '        .controls button:hover {',
                            '            background: #444;',
                            '        }',
                            '        svg {',
                            '            width: 100%;',
                            '            height: auto;',
                            '            max-height: 100%;',
                            '            transform-origin: center center;',
                            '            transition: transform 0.2s ease;',
                            '        }',
                            '    </style>',
                            '    <script>',
                            '        let currentScale = 1;',
                            '        let isDragging = false;',
                            '        let startX, startY;',
                            '        let translateX = 0, translateY = 0;',
                            '        let lastTranslateX = 0, lastTranslateY = 0;',
                            '',
                            '        function zoom(factor) {',
                            '            currentScale *= factor;',
                            '            currentScale = Math.max(0.1, Math.min(50, currentScale));',
                            '            updateTransform();',
                            '        }',
                            '',
                            '        function resetZoom() {',
                            '            currentScale = 1;',
                            '            translateX = 0;',
                            '            translateY = 0;',
                            '            lastTranslateX = 0;',
                            '            lastTranslateY = 0;',
                            '            updateTransform();',
                            '        }',
                            '',
                            '        function updateTransform() {',
                            '            const svg = document.querySelector("svg");',
                            '            svg.style.transform = `translate(${translateX}px, ${translateY}px) scale(${currentScale})`;',
                            '        }',
                            '',
                            '        window.addEventListener("load", () => {',
                            '            const container = document.querySelector(".svg-container");',
                            '            const svg = document.querySelector("svg");',
                            '',
                            '            container.addEventListener("mousedown", (e) => {',
                            '                isDragging = true;',
                            '                startX = e.clientX - translateX;',
                            '                startY = e.clientY - translateY;',
                            '                container.style.cursor = "grabbing";',
                            '            });',
                            '',
                            '            document.addEventListener("mousemove", (e) => {',
                            '                if (!isDragging) return;',
                            '                translateX = e.clientX - startX;',
                            '                translateY = e.clientY - startY;',
                            '                updateTransform();',
                            '            });',
                            '',
                            '            document.addEventListener("mouseup", () => {',
                            '                if (!isDragging) return;',
                            '                isDragging = false;',
                            '                container.style.cursor = "grab";',
                            '                lastTranslateX = translateX;',
                            '                lastTranslateY = translateY;',
                            '            });',
                            '',
                            '            container.addEventListener("mouseleave", () => {',
                            '                if (isDragging) {',
                            '                    isDragging = false;',
                            '                    container.style.cursor = "grab";',
                            '                    lastTranslateX = translateX;',
                            '                    lastTranslateY = translateY;',
                            '                }',
                            '            });',
                            '',
                            '            // Set initial cursor style',
                            '            container.style.cursor = "grab";',
                            '        });',
                            '    <\/script>',
                            '</head>',
                            '<body>',
                            '    <div class="svg-container">',
                            '        <div class="controls">',
                            '            <button onclick="zoom(1.2)">Zoom In</button>',
                            '            <button onclick="zoom(0.8)">Zoom Out</button>',
                            '            <button onclick="resetZoom()">Reset</button>',
                            '        </div>',
                            `        ${svg.outerHTML}`,
                            '    </div>',
                            '</body>',
                            '</html>'
                        ].join('\n');
                    }

                    // Add SVGs to the window
                    svgs.forEach((svg, index) => {
                        const container = document.createElement('div')
                        container.className = 'pipeline-container'

                        const title = document.createElement('div')
                        title.className = 'pipeline-title'
                        title.textContent = index === 0 ? 'Main Pipeline' : `Child Pipeline ${index}`
                        container.appendChild(title)

                        const iframe = document.createElement('iframe')
                        iframe.srcdoc = createIframeContent(svg)
                        container.appendChild(iframe)

                        pipelinesContainer.appendChild(container)
                    })
                },
            },
            data: function() {
                return {
                    "content": [],
                    "streams": []
                }
            }
        })

        app.component('v4lslider', {
            props: {
                slider: {
                    type: Object,
                    required: true
                },
                name: {
                    type: String,
                    required: true
                },
            },
            data: function() {
                return {
                    "val": this.slider.value,
                }
            },
            template: `
                <div>
                    <input type='range'
                        :min='slider.min'
                        :max='slider.max'
                        :value='val'
                        :step='slider.step'
                        :id="'range-input-' + name"
                        @change='$emit("onchange", val)'
                        v-on:input='val = $event.target.value'
                        class='slider'>
                    <span>{{val}}</span>
                </div>`
        })

        app.component('streamform', {
            props: {
                device: {
                    type: Object,
                    required: true
                },
                streams: {
                    type: Object,
                    required: true
                },
            },
            mounted: function() {
                this.stream_options.encoders = this.device.formats
                    .map((format) => this.encodeToStr(format.encode))
            },
            watch: {
                streams: {
                    handler: function(streams, _) {
                        this.stream = streams
                            .filter((stream) =>
                                stream.video_and_stream.video_source.Local && stream.video_and_stream.video_source.Local.device_path == this.device.source
                                || stream.video_and_stream.video_source.Gst && stream.video_and_stream.video_source.Gst.source.Fake == this.device.source)[0]
                        if(!this.stream) {
                            return
                        }

                        switch (this.stream.video_and_stream.stream_information.configuration.type) {
                            case "redirect": break
                            default: {
                                this.stream_setting.configuration.encode = this.stream.video_and_stream.stream_information.configuration.encode
                                this.stream_setting.configuration.size = {
                                    height: this.stream.video_and_stream.stream_information.configuration.height,
                                    width: this.stream.video_and_stream.stream_information.configuration.width
                                }
                                this.stream_setting.configuration.interval = this.stream.video_and_stream.stream_information.configuration.frame_interval
                            }
                        }

                        this.stream_setting.configuration.endpoints = this.stream.video_and_stream.stream_information.endpoints ?
                            this.stream.video_and_stream.stream_information.endpoints.join(", ") : ""
                        this.stream_setting.extended_configuration.thermal = Boolean(this.stream.video_and_stream.stream_information.extended_configuration?.thermal)
                        this.stream_setting.extended_configuration.disable_mavlink = Boolean(this.stream.video_and_stream.stream_information.extended_configuration?.disable_mavlink)
                        this.stream_setting.extended_configuration.disable_zenoh = Boolean(this.stream.video_and_stream.stream_information.extended_configuration?.disable_zenoh)
                        this.stream_setting.extended_configuration.disable_thumbnails = Boolean(this.stream.video_and_stream.stream_information.extended_configuration?.disable_thumbnails)
                        this.stream_setting.extended_configuration.disable_recording = Boolean(this.stream.video_and_stream.stream_information.extended_configuration?.disable_recording)
                    },
                    deep: true
                },
                stream_setting: {
                    handler: function(stream_setting, _) {
                        console.log(JSON.stringify(stream_setting, undefined, 2))

                        switch (stream_setting.configuration.type) {
                            case "redirect": break
                            default: {
                        this.stream_options.encoders =
                            this.device.formats
                                .map((format) => this.encodeToStr(format.encode))

                        this.stream_options.sizes =
                            this.device.formats
                                .filter((format) => this.encodeToStr(format.encode) == stream_setting.configuration.encode)
                                .map((format) => format.sizes)[0]
                                // Sort width by preference
                                ?.sort((size1, size2) => (10 * size2.width + size2.height) - (10 * size1.width + size1.height))

                        console.log(this.stream_options.sizes)

                        let chosen_size = stream_setting.configuration.size
                        if(chosen_size == undefined) {
                            return
                        }

                        this.stream_options.intervals =
                            this.stream_options.sizes
                                .filter((size) => size.width == chosen_size.width && size.height == chosen_size.height)[0].intervals

                            }
                        }
                    },
                    deep: true
                }
            },
            methods: {
                encodeToStr: function(encode) {
                    // encode is an enum that contains the encode as string or a object that describes the encode
                    return typeof(encode) == 'object' ? Object.values(encode)[0] : encode
                },
            },
            data: function() {
                return {
                    stream_setting: {
                        name: this.device.source + ' - ' + this.device.name,
                        source: this.device.source,
                        endpoints: undefined,
                        configuration: {
                            encode: undefined,
                            size: undefined,
                            interval: undefined,
                        },
                        extended_configuration: {
                            thermal: undefined,
                            disable_mavlink: undefined,
                            disable_zenoh: undefined,
                            disable_thumbnails: undefined,
                            disable_recording: undefined,
                        },
                    },
                    stream_options: {
                        encoders: undefined,
                        sizes: undefined,
                        intervals: undefined,
                    },
                    stream: undefined
                }
            },
            template: `
                <form
                >
                    <p>
                        <label>Name: </label>
                        <input
                            name="name"
                            type="text"
                            autocomplete="off"
                            v-model="stream_setting.name"
                        >
                    </p>

                    <div>
                        <label>Encode: </label>
                        <select
                            v-model="stream_setting.configuration.encode"
                            v-bind:disabled="stream_setting.source == 'Redirect'"
                        >
                            <option
                                v-for="encode in stream_options.encoders"
                                :value="encode"
                            >
                                {{ encode }}
                            </option>
                        </select>
                    </div>
                    <div>
                        <label>Size: </label>
                        <select
                            v-model="stream_setting.configuration.size"
                            v-bind:disabled="stream_setting.source == 'Redirect'"
                        >
                            <option
                                v-for="size in stream_options.sizes"
                                v-bind:value="{width: size.width, height: size.height}"
                            >
                                {{ size.width }} x {{ size.height }}
                            </option>
                        </select>
                    </div>
                    <div>
                        <label>FPS: </label>
                        <select
                            v-model="stream_setting.configuration.interval"
                            v-bind:disabled="stream_setting.source == 'Redirect'"
                        >
                            <option
                                v-for="interval in this.stream_options.intervals"
                                v-bind:value="interval"
                            >
                                {{ interval.denominator / interval.numerator }}
                            </option>
                        </select>
                    </div>
                    <div>
                        <label>Thermal: </label>
                        <input
                            type="checkbox"
                            v-model="stream_setting.extended_configuration.thermal"
                        >
                    </div>
                    <div>
                        <label>Disable Mavlink: </label>
                        <input
                            type="checkbox"
                            v-model="stream_setting.extended_configuration.disable_mavlink"
                        >
                    </div>
                    <div>
                        <label>Disable Zenoh: </label>
                        <input
                            type="checkbox"
                            v-model="stream_setting.extended_configuration.disable_zenoh"
                        >
                    </div>
                    <div>
                        <label>Disable Thumbnails: </label>
                        <input
                            type="checkbox"
                            v-model="stream_setting.extended_configuration.disable_thumbnails"
                        >
                    </div>
                    <div>
                        <label>Disable Recording: </label>
                        <input
                            type="checkbox"
                            v-model="stream_setting.extended_configuration.disable_recording"
                        >
                    </div>

                    <p>
                        <label>Endpoints: </label>
                        <input
                            type="text"
                            autocomplete="off"
                            placeholder="udp://0.0.0.0:5600"
                            v-model="stream_setting.endpoints"
                        >
                    </p>
                    <button type="button" @click="$emit('onconfigure', stream_setting)">Configure stream</button>
                </form>
            `
        })

        app.mount("#app")
    </script>
</body>

</html>
